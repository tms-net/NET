---
marp: true
theme: uncover
---

![bg](img/title_page_bg.jpg)

# Entity Framework Core Querying

---
<!-- _class: slide -->
## EF Migrations
In real world projects, data models change as features get implemented: new entities or properties are added and removed, and database schemas needs to be changed accordingly to be kept in sync with the application. 

### Install the tools
First, you'll have to install the [EF Core command-line tools](https://docs.microsoft.com/en-us/ef/core/cli/):
 - [.NET Core CLI tools](https://docs.microsoft.com/en-us/ef/core/cli/dotnet), which work on all platforms.
 - If you're more comfortable working inside Visual Studio or have experience with EF6 migrations, you can also use the [Package Manager Console tools](https://docs.microsoft.com/en-us/ef/core/cli/powershell).

 ### Create your first migration
 You're now ready to add your first migration! Instruct EF Core to create a migration named **InitialCreate**:
```
// .NET Core CLI

dotnet ef migrations add InitialCreate
```
```
// Visual Studio powershell tools

Add-Migration InitialCreate
```

Three files are added to your project under the Migrations directory:

 - XXXXXXXXXXXXXX_InitialCreate.cs - The main migrations file. Contains the operations necessary to apply the migration (in Up) and to revert it (in Down).
 - XXXXXXXXXXXXXX_InitialCreate.Designer.cs - The migrations metadata file. Contains information used by EF.
 - TMSContextModelSnapshot.cs - A snapshot of your current model. Used to determine what changed when adding the next migration.

Alternatively, you can specify the directory at generation time as follows:
```
// .NET Core CLI

dotnet ef migrations add InitialCreate --output-dir Your/Directory
```
```
// Visual Studio powershell tools

Add-Migration InitialCreate -OutputDir Your\Directory
```

### Create your database and schema
```
// .NET Core CLI

dotnet ef database update
```
```
// Visual Studio powershell tools

Update-Database
```
A few days have passed, and you decided to add a bio info for your students.
### Evolve your model
```
public class Student
{
    public string ShortBio { get; set; }
}
```
Your model and your production database are now out of sync - we must add a new column to your database schema. Let's create a new migration for this:
```
// .NET Core CLI

dotnet ef migrations add AddStudentShortBio
```
```
// Visual Studio powershell tools

Add-Migration AddStudentShortBio
```

### Excluding parts of your model
Sometimes you may want to reference types from another DbContext. This can lead to migration conflicts. To prevent this, exclude the type from the migrations of one of the DbContexts.
```
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<IdentityUser>()
        .ToTable("AspNetUsers", t => t.ExcludeFromMigrations());
}
```

### Remove a migration
Sometimes you add a migration and realize you need to make additional changes to your EF Core model before applying it. To remove the last migration, use this command.
```
// .NET Core CLI

dotnet ef migrations remove
```
```
// Visual Studio powershell tools

Remove-Migration
```

### Customize migration code
While EF Core generally creates accurate migrations, you should always review the code and make sure it corresponds to the desired change; in some cases, it is even necessary to do so.

**Column renames**
One notable example where customizing migrations is required is when renaming a property. For example, if you rename a property from `ShortBio` to `Biography`. EF Core is generally unable to know when the intention is to drop a column and create a new one (two separate changes), and when a column should be renamed. If the above migration is applied as-is, all your customer names will be lost. To rename a column, replace the above generated migration with the following:
```
migrationBuilder.RenameColumn(
    name: "Name",
    table: "Customers",
    newName: "FullName");
```

**Adding raw SQL**
While renaming a column can be achieved via a built-in API, in many cases that is not possible. For example, we may want to replace existing FirstName and LastName properties with a single, new FullName property. The migration generated by EF Core will be the following:
```
migrationBuilder.DropColumn(
    name: "Name",
    table: "Student");

migrationBuilder.DropColumn(
    name: "LastName",
    table: "Student");

migrationBuilder.AddColumn<string>(
    name: "FullName",
    table: "Student",
    nullable: true);
```
As before, this would cause unwanted data loss. To transfer the data from the old columns, we rearrange the migrations and introduce a raw SQL operation as follows:
```
migrationBuilder.AddColumn<string>(
    name: "FullName",
    table: "Student",
    nullable: true);

migrationBuilder.Sql(
@"
    UPDATE Customer
    SET FullName = FirstName + ' ' + LastName;
");

migrationBuilder.DropColumn(
    name: "FirstName",
    table: "Customer");

migrationBuilder.DropColumn(
    name: "LastName",
    table: "Customer");
```

**Arbitrary changes via raw SQL**
Raw SQL can also be used to manage database objects that EF Core isn't aware of. To do this, add a migration without making any model change and add appropriate code to it.
```
migrationBuilder.Sql(
@"
    EXEC ('CREATE PROCEDURE getFullName
        @LastName nvarchar(50),
        @FirstName nvarchar(50)
    AS
        RETURN @LastName + @FirstName;')");
```

This can be used to manage any aspect of your database, including:
 - Stored procedures
 - Full-Text Search
 - Functions
 - Triggers
 - Views

### Listing migrations
You can list all existing migrations as follows:
```
// .NET Core CLI

dotnet ef migrations list
```
```
// Visual Studio powershell tools

Get-Migration
```

### Applying Migrations
Once your migrations have been added, they need to be deployed and applied to your databases. There are various strategies for doing this, with some being more appropriate for production environments, and others for the development lifecycle.

**SQL scripts**
- Basic Usage
 The following generates a SQL script from a blank database to the latest migration:
 ```
 dotnet ef migrations script
 ```

- With From (to implied)
 The following generates a SQL script from the given migration to the latest migration.
 ```
 dotnet ef migrations script AddNewTables
 ```

- With From and To
 The following generates a SQL script from the specified from migration to the specified to migration.
 ```
 dotnet ef migrations script AddNewTables AddAuditTable
 ```

*Idempotent SQL scripts*
The SQL scripts generated above can only be applied to change your schema from one migration to another; it is your responsibility to apply the script appropriately, and only to database in the correct migration state. EF Core also supports generating idempotent scripts, which internally check which migrations have already been applied (via the migrations history table), and only apply missing ones.
```
dotnet ef migrations script --idempotent
```

**Command-line tools**
The EF command-line tools can be used to apply migrations to a database.

The following updates your database to the latest migration:
```
dotnet ef database update
```

The following updates your database to a given migration:
```
dotnet ef database update AddNewTables
```

Note that this can be used to roll back to an earlier migration as well.

**Apply migrations at runtime**
It's possible for the application itself to apply migrations programmatically, typically during startup. For example, a typical ASP.NET application can do the following:
```
public static void Main(string[] args)
{
    var host = CreateHostBuilder(args).Build();

    using (var scope = host.Services.CreateScope())
    {
        var db = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        db.Database.Migrate();
    }

    host.Run();
}
```

### Custom Migrations Operations
The MigrationBuilder API allows you to perform many different kinds of operations during a migration, but it's far from exhaustive. However, the API is also extensible allowing you to define your own operations. There are two ways to extend the API: Using the Sql() method, or by defining custom MigrationOperation objects.

**Using MigrationBuilder.Sql()**
```
private static OperationBuilder<SqlOperation> CreateUser(
    this MigrationBuilder migrationBuilder,
    string name,
    string password)
    => migrationBuilder.Sql($"CREATE USER {name} WITH PASSWORD '{password}';");
```

**Using a MigrationOperation**
To decouple the custom operation from the SQL, you can define your own MigrationOperation to represent it. The operation is then passed to the provider so it can determine the appropriate SQL to generate.
```
internal class CreateUserOperation : MigrationOperation
{
    public string Name { get; set; }
    public string Password { get; set; }
}
```
With this approach, the extension method just needs to add one of these operations to `MigrationBuilder.Operations`.
```
private static OperationBuilder<CreateUserOperation> CreateUser(
    this MigrationBuilder migrationBuilder,
    string name,
    string password)
{
    var operation = new CreateUserOperation { Name = name, Password = password };
    migrationBuilder.Operations.Add(operation);

    return new OperationBuilder<CreateUserOperation>(operation);
}
```

### Custom Migrations History Table
By default, EF Core keeps track of which migrations have been applied to the database by recording them in a table named __EFMigrationsHistory. For various reasons, you may want to customize this table to better suit your needs.
```
protected override void OnConfiguring(DbContextOptionsBuilder options)
    => options.UseSqlServer(
        _connectionString,
        x => x.MigrationsHistoryTable("__MyMigrationsHistory", "mySchema"));
```

### Reverse Engineering
Reverse engineering is the process of scaffolding entity type classes and a DbContext class based on a database schema. It can be performed using the Scaffold-DbContext command of the EF Core Package Manager Console (PMC) tools or the dotnet ef dbcontext scaffold command of the .NET Command-line Interface (CLI) tools.

**Connection string**
The first argument to the command is a connection string to the database.
```
// .NET Core CLI

dotnet ef dbcontext scaffold "Data Source=.\SQLExpress;Initial Catalog=TMS3;Integrated Security=True" Microsoft.EntityFrameworkCore.SqlServer
```
```
// Visual Studio powershell tools

Scaffold-DbContext "Data Source=.\SQLExpress;Initial Catalog=TMS3;Integrated Security=True" Microsoft.EntityFrameworkCore.SqlServer
```

**Specifying tables**
All tables in the database schema are reverse engineered into entity types by default. You can limit which tables are reverse engineered by specifying schemas and tables.
```
// .NET Core CLI

dotnet ef dbcontext scaffold ... --table Student --table Homeworks
```
```
// Visual Studio powershell tools

Scaffold-DbContext ... -Tables Student -Tables Homeworks
```

**Preserving names**
Table and column names are fixed up to better match the .NET naming conventions for types and properties by default. Specifying the `-UseDatabaseNames` switch in PMC or the `--use-database-names` option in the .NET Core CLI will disable this behavior preserving the original database names as much as possible. Invalid .NET identifiers will still be fixed and synthesized names like navigation properties will still conform to .NET naming conventions.

**Fluent API or Data Annotations**
Entity types are configured using the Fluent API by default. Specify `-DataAnnotations` (PMC) or `--data-annotations` (.NET Core CLI) to instead use data annotations when possible.

**DbContext name**
The scaffolded DbContext class name will be the name of the database suffixed with Context by default. To specify a different one, use `-Context` in PMC and `--context` in the .NET Core CLI.

**Directories and namespaces**
You can specify the directory where classes are scaffolded using `--output-dir` and `--context-dir` (.NET Core CLI) `-OutputDir` and `-ContextDir` (PMC) can be used to scaffold the DbContext class into a separate directory from the entity type classes.

## Query Data
Entity Framework Core uses Language-Integrated Query (LINQ) to query data from the database. EF Core passes a representation of the LINQ query to the database provider. Database providers in turn translate it to database-specific query language (for example, SQL for a relational database).

### Loading all data
```
using (var context = new TMSContext())
{
    var students = context.Students.ToList();
}
```

### Loading a single entity
```
using (var context = new TMSContext())
{
    var student = context.Students.Single(b => b.Id == 1);
}
```

### Filtering
```
using (var context = new TMSContext())
{
    var students = context.Students
        .Where(b => b.Name.Contains("dm"))
        .ToList();
}
```

### The life of a query
The following description is a high-level overview of the process each query goes through.

 - The LINQ query is processed by Entity Framework Core to build a representation that is ready to be processed by the database provider
    *  The result is cached so that this processing does not need to be done every time the query is executed
 - The result is passed to the database provider
    *  The database provider identifies which parts of the query can be evaluated in the database
    *  These parts of the query are translated to database-specific query language (for example, SQL for a relational database)
    *  A query is sent to the database and the result set returned (results are values from the database, not entity instances)
 - For each item in the result set
    *  If the query is a tracking query, EF checks if the data represents an entity already in the change tracker for the context instance
    *  If so, the existing entity is returned
    *  f not, a new entity is created, change tracking is set up, and the new entity is returned
    *  f the query is a no-tracking query, then a new entity is always created and returned

### Client vs. Server Evaluation
As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible. EF Core converts parts of the query into parameters, which it can evaluate on the client side. The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server. EF Core supports partial client evaluation in the top-level projection (essentially, the last call to Select()). If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client. If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.

**Client evaluation in the top-level projection**
In the following example, a helper method is used to generate URLs for pull requests, which are returned from a SQL Server database. Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL. All other aspects of the query are evaluated in the database, but passing the returned URL through this method is done on the client.
```
var homeworks = context.Homeworks
    .OrderByDescending(hw => hw.Mark)
    .Select(
        hw => new { Id = hw.Id, PR = GenerateUrl(hw.PullRequest) })
    .ToList();
```
```
public static string StandardizeUrl(string prId)
{
    if (stirng.IsNullOrEpty(prId))
        return "https://github.com/tms-net/NET06";

    return "https://github.com/tms-net/NET06/pull/" + prId;
}
```

**nsupported client evaluation**
While client evaluation is useful, it can result in poor performance sometimes. Consider the following query, in which the helper method is now used in a where filter. Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client. Based on the filter and the amount of data on the server, client evaluation could result in poor performance. So Entity Framework Core blocks such client evaluation and throws a runtime exception.
```
var homeworks = context.Homeworks
    .Where(hw => GenerateUrl(hw.PullRequest).Contains("pull"))
    .ToList();
```

**Explicit client evaluation**
You may need to force into client evaluation explicitly in certain cases like following

 - The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.
 - The LINQ operator being used has no server-side translation.

 In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList`. By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory. Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database. Depending on the particular usage, you should evaluate which method is more useful for the case.
 ```
var homeworks = context.Homeworks
    .AsEnumerable()
    .Where(hw => GenerateUrl(hw.PullRequest).Contains("pull"))
    .ToList();
```

### Tracking vs. No-Tracking Queries
Tracking behavior controls if Entity Framework Core will keep information about an entity instance in its change tracker. If an entity is tracked, any changes detected in the entity will be persisted to the database during SaveChanges(). EF Core will also fix up navigation properties between the entities in a tracking query result and the entities that are in the change tracker.

**Keyless entity types are never tracked.*

**Tracking queries**
By default, queries that return entity types are tracking. Which means you can make changes to those entity instances and have those changes persisted by SaveChanges().
```
using (var context = new TMSContext())
{
    var student = context.Students.Single(b => b.Id == 1);
    student.ShortBio = "Born to code";
    context.SaveChanges();    
}
```

**No-tracking queries**
No tracking queries are useful when the results are used in a read-only scenario. They're quicker to execute because there's no need to set up the change tracking information.
```
var students = context.Students
                .AsNoTracking()
                .ToList();  
```

```
context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
var students = context.Students
            .ToList();
```

**Tracking and custom projections**
Even if the result type of the query isn't an entity type, EF Core will still track entity types contained in the result by default. In the following query, which returns an anonymous type, the instances of Student in the result set will be tracked.
```
var students = context.Students
    .Select(s => new { Student = s, HomeworkCount = s.Homeworks.Count() });
```

If the result set contains entity types coming out from LINQ composition, EF Core will track them.
```
var students = context.Students
    .Select(s => new { Student = s, Homework = s.Homeworks.OrderBy(p => p.Mark).LastOrDefault() });
```

### Loading Related Data
Entity Framework Core allows you to use the navigation properties in your model to load related entities. There are three common O/RM patterns used to load related data.

 - **Eager loading** means that the related data is loaded from the database as part of the initial query.
 - **Explicit loading** means that the related data is explicitly loaded from the database at a later time.
 - **Lazy loading** means that the related data is transparently loaded from the database when the navigation property is accessed.

### Eager loading
You can use the Include method to specify related data to be included in query results.
```
using (var context = new TMSContext())
{
    var students = context.Students
            .Include(s => s.Homeworks)
            .ToList();
}
 ```
 You can include related data from multiple relationships in a single query.
```
using (var context = new TMSContext())
{
    var students = context.Students
            .Include(s => s.Homeworks)
            .Include(s => s.Avatar)
            .ToList();
}
```

**Including multiple levels**
You can drill down through relationships to include multiple levels of related data using the ThenInclude method.
```
using (var context = new TMSContext())
{
    var students = context.Students
            .Include(s => s.Homeworks)
            .ThenInclude(hw => hw.Reviewer)
            .ToList();
}
```

You can chain multiple calls to ThenInclude to continue including further levels of related data.
```
using (var context = new TMSContext())
{
    var students = context.Students
            .Include(s => s.Homeworks)
            .ThenInclude(hw => hw.Reviewer)
            .ThenInclude(r => r.Avatar)
            .ToList();
}
```

You may want to include multiple related entities for one of the entities that is being included.
```
using (var context = new TMSContext())
{
    var students = context.Students
            .Include(s => s.Homeworks)
            .ThenInclude(hw => hw.Reviewer)
            .ThenInclude(r => r.Avatar)
            .Include(s => s.Homeworks)
            .ThenInclude(hw => hw.Tags)
            .ToList();
}
```

**Filtered include**
When applying Include to load related data, you can add certain enumerable operations to the included collection navigation, which allows for filtering and sorting of the results.

Supported operations are: `Where`, `OrderBy`, `OrderByDescending`, `ThenBy`, `ThenByDescending`, `Skip`, and `Take`.
```
using (var context = new TMSContext())
{
    var students = context.Students
            .Include(s => s.Homeworks
                .Where(hw => hw.StudentId == 1)
                .OrderByDescending(hw => hw.Name)
                .Take(5))
            .ToList();
}
```

### Explicit loading
You can explicitly load a navigation property via the DbContext.Entry(...) API.
```
using (var context = new BloggingContext())
{
    var student = context.Students
        .Single(s => s.Id == 1);

    context.Entry(student)
        .Collection(b => b.Homeworks)
        .Load();

    context.Entry(student)
        .Reference(b => b.Avatar)
        .Load();
}
```
You can also explicitly load a navigation property by executing a separate query that returns the related entities. If change tracking is enabled, then when query materializes an entity, EF Core will automatically set the navigation properties of the newly loaded entity to refer to any entities already loaded, and set the navigation properties of the already-loaded entities to refer to the newly loaded entity.

**Querying related entities**
You can also get a LINQ query that represents the contents of a navigation property.
```
using (var context = new BloggingContext())
{
    var student = context.Students
        .Single(s => s.Id == 1);

    context.Entry(student)
        .Collection(b => b.Homeworks)
        .Query()
        .Count();
}
```

You can also filter which related entities are loaded into memory.
```
using (var context = new BloggingContext())
{
    var student = context.Students
        .Single(s => s.Id == 1);

    context.Entry(student)
        .Collection(b => b.Homeworks)
        .Query()
        .Where(p => p.Mark > 3)
        .ToList();
}
```

### Lazy loading with proxies
The simplest way to use lazy-loading is by installing the [Microsoft.EntityFrameworkCore.Proxies](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Proxies/) package and enabling it with a call to UseLazyLoadingProxies. For example:
```
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    => optionsBuilder
        .UseLazyLoadingProxies()
        .UseSqlServer(myConnectionString);
```
EF Core will then enable lazy loading for any navigation property that can be overridden--that is, it must be virtual and on a class that can be inherited from.
```
public class Student
{
    public int Id { get; set; }
    public string Name { get; set; }

    public virtual ICollection<Homework> Homeworks { get; set; }
}

public class Homework
{
    public int Id { get; set; }
    public string Name { get; set; }

    public virtual Student Student { get; set; }
}
```
*Lazy loading can cause unneeded extra database roundtrips to occur (the so-called N+1 problem), and care should be taken to avoid this.*

### Lazy loading without proxies
Lazy-loading proxies work by injecting the ILazyLoader service into an entity, as described in [Entity Type Constructors](https://docs.microsoft.com/en-us/ef/core/modeling/constructors#injecting-services). For example:
```
public class Student
{
    private ICollection<Homework> _homeworks;

    public Student()
    {
    }

    private Student(ILazyLoader lazyLoader)
    {
        LazyLoader = lazyLoader;
    }
    
    private ILazyLoader LazyLoader { get; set; }

    public int Id { get; set; }
    public string Name { get; set; }

    public ICollection<Homework> Homeworks
    { 
        get => LazyLoader.Load(this, ref _homeworks);
        set => _homeworks = value;
     }
}

public class Homework
{
    private Student _student;

    public Homework()
    {
    }

    private Homework(ILazyLoader lazyLoader)
    {
        LazyLoader = lazyLoader;
    }

    private ILazyLoader LazyLoader { get; set; }

    public int Id { get; set; }
    public string Name { get; set; }

    public Student Student
    { 
        get => LazyLoader.Load(this, ref _student);
        set => _student = value; 
     }
}
```

This method requires a reference to the ILazyLoader service, which is defined in the Microsoft.EntityFrameworkCore.Abstractions package. This package contains a minimal set of types so that there is little impact in depending on it. However, to completely avoid depending on any EF Core packages in the entity types, it's possible to inject the ILazyLoader.Load method as a delegate.
```
public class Student
{
    private ICollection<Homework> _homeworks;

    public Student()
    {
    }

    private Student(ILazyLoader lazyLoader)
    {
        LazyLoader = lazyLoader;
    }
    
    private ILazyLoader LazyLoader { get; set; }

    public int Id { get; set; }
    public string Name { get; set; }

    public ICollection<Homework> Homeworks
    { 
        get => LazyLoader.Load(this, ref _homeworks);
        set => _homeworks = value;
     }
}

public class Homework
{
    private Student _student;

    public Homework()
    {
    }

    private Homework(ILazyLoader lazyLoader)
    {
        LazyLoader = lazyLoader;
    }

    private ILazyLoader LazyLoader { get; set; }

    public int Id { get; set; }
    public string Name { get; set; }

    public Student Student
    { 
        get => LazyLoader.Load(this, ref _student);
        set => _student = value; 
     }
}
```
```
public static class PocoLoadingExtensions
{
    public static TRelated Load<TRelated>(
        this Action<object, string> loader,
        object entity,
        ref TRelated navigationField,
        [CallerMemberName] string navigationName = null)
        where TRelated : class
    {
        loader?.Invoke(entity, navigationName);

        return navigationField;
    }
}
```

### Split queries
In relational databases, all related entities are loaded by introducing JOINs in single query.
```
SELECT [s].[Id], [s].[Name], [h].[Id], [h].[StudentId], [h].[Name]
FROM [Students] AS [s]
LEFT JOIN [Homeworks] AS [h] ON [s].[Id] = [h].[StudentId]
ORDER BY [s].[Id], [h].[Id]
```

EF allows you to specify that a given LINQ query should be split into multiple SQL queries. Instead of JOINs, split queries generate an additional SQL query for each included collection navigation:
```
using (var context = new TMSContext())
{
    var students = context.Students
        .Include(blog => blog.Homeworks)
        .AsSplitQuery()
        .ToList();
}
```

It will produce the following SQL:
```
SELECT [s].[Id], [s].[Name]
FROM [Students]
ORDER BY [s].[Id]

SELECT [s].[Id], [s].[Name], [h].[Id], [h].[StudentId], [h].[Name]
FROM [Students] AS [s]
INNER JOIN [Homeworks] AS [h] ON [s].[Id] = [h].[StudentId]
ORDER BY [s].[Id]
```

When split queries are configured as the default, it's still possible to configure specific queries to execute as single queries:
```
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(
            @"Data Source=.\SQLExpress;Initial Catalog=TMS;Integrated Security=True",
            o => o.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery));
}
```
```
using (var context = new TMSContext())
{
    var students = context.Students
        .Include(blog => blog.Homeworks)
        .AsSingleQuery()
        .ToList();
}
```

### Raw SQL Queries
You can use the `FromSqlRaw` extension method to begin a LINQ query based on a raw SQL query. `FromSqlRaw` can only be used on query roots, that is directly on the `DbSet<>`.
```
var students = context.Students
    .FromSqlRaw("SELECT * FROM dbo.Students")
    .ToList();
```
Raw SQL queries can be used to execute a stored procedure.
```
var students = context.Students
    .FromSqlRaw("EXECUTE dbo.GetBestStudents")
    .ToList();
```

**Passing parameters**
*Always use parameterization for raw SQL queries!*.
`FromSqlRaw` syntax may look like String.Format syntax, the supplied value is wrapped in a DbParameter and the generated parameter name inserted where the {0} placeholder was specified. `FromSqlInterpolated` is similar to `FromSqlRaw` but allows you to use string interpolation syntax.
```
var minMark = 3;

var students = context.Students
    .FromSqlRaw("EXECUTE dbo.GetBestStudents {0}", minMark)
    .ToList();

 students = context.Students
    .FromSqlInterpolated($"EXECUTE dbo.GetBestStudents {minMark}")
    .ToList();
```

You can also construct a DbParameter and supply it as a parameter value.
```
var minMark = new SqlParameter("minMark", 3);

var students = context.Students
    .FromSqlRaw("EXECUTE dbo.GetBestStudents @minMark", minMark)
    .ToList();
```

**Composing with LINQ**
You can compose on top of the initial raw SQL query using LINQ operators.
```
var minMark = 3;

var students = context.Students
    .FromSqlInterpolated($"SELECT * dbo.GetBestStudents {minMark}")
    .Where(s => s.LastName.Contains("a"))
    .OrderByDescending(s => s.Name)
    .ToList();
```

*TODO: View Generated SQL*

**Including related data**
The `Include` method can be used to include related data, just like with any other LINQ query:
```
var minMark = 3;

var students = context.Students
    .FromSqlInterpolated($"SELECT * dbo.GetBestStudents {minMark}")
    .Include(b => b.Homeworks)
    .ToList();
```

**Change Tracking**
Queries that use the `FromSqlRaw` or `FromSqlInterpolated` methods follow the exact same change tracking rules as any other LINQ query in EF Core. For example, if the query projects entity types, the results will be tracked by default.

**Limitations**
There are a few limitations to be aware of when using raw SQL queries:

 - The SQL query must return data for all properties of the entity type.
 - The column names in the result set must match the column names that properties are mapped to.
 - The SQL query can't contain related data.

 ### User-defined function mapping

*TODO: get through the examples if have time*

 See [https://docs.microsoft.com/en-us/ef/core/querying/user-defined-function-mapping](https://docs.microsoft.com/en-us/ef/core/querying/user-defined-function-mapping)

 ### Global Query Filters
 Global query filters are LINQ query predicates applied to Entity Types in the metadata model (usually in OnModelCreating). Some common applications of this feature are:

 - **Soft delete** - An Entity Type defines an IsDeleted property.
 - **Multi-tenancy** - An Entity Type defines a TenantId property.

 First, define entities
```
public class Student
{
#pragma warning disable IDE0051, CS0169 // Remove unused private members
    private string _tenantId;
#pragma warning restore IDE0051, CS0169 // Remove unused private members

    public int Id { get; set; }
    public string Name { get; set; }

    public List<Homework> Homeworks { get; set; }
}


public class Homework
{
    public int Id { get; set; }
    public string Name { get; set; }
    public bool IsDeleted { get; set; }

    public virtual Student Student { get; set; }
}
```

Next, configure the query filters in `OnModelCreating` using the `HasQueryFilter` API.
```
modelBuilder.Entity<Student>().HasQueryFilter(s => EF.Property<string>(s, "_tenantId") == _tenantId);
modelBuilder.Entity<Homework>().HasQueryFilter(h => !h.IsDeleted);
```

**Use of navigations**
You can also use navigations in defining global query filters.
```
modelBuilder.Entity<Student>().HasQueryFilter(s => s.Homeworks.Count > 0);
```

*TODO: view generated SQL*

**Disabling Filters**
Filters may be disabled for individual LINQ queries by using the `IgnoreQueryFilters` operator.
```
students = db.Students
    .Include(b => b.Homeworks)
    .IgnoreQueryFilters()
    .ToList();
```

*Filters can only be defined for the root Entity Type of an inheritance hierarchy.*