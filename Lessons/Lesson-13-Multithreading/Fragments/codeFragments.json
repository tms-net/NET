{"codeFragments":[{"label":"Write to console from different threads","content":"\r\n        // Threads vs Processes\r\n        // A thread is analogous to the operating system process in which your application runs.\r\n        // Just as processes run in parallel on a computer, threads run in parallel within a single process.\r\n        // Processes are fully isolated from each other; threads have just a limited degree of isolation.\r\n        // In particular, threads share (heap) memory with other threads running in the same application.\r\n        // This, in part, is why threading is useful: one thread can fetch data in the background, for instance,\r\n        // while another thread can display the data as it arrives.\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            Thread t = new Thread (new ThreadStart(WriteY)); // Kick off a new thread\r\n            t.Start();                               // running WriteY()\r\n        \r\n            // Simultaneously, do something on the main thread.\r\n            for (int i = 0; i < 1000; i++) Console.Write (\"x\");\r\n        }\r\n\r\n        static void WriteY()\r\n        {\r\n            for (int i = 0; i < 1000; i++) Console.Write (\"y\");\r\n        }"},{"label":"Use of ParameterizedTreadStart","content":"\r\n        static void Main(string[] args)\r\n        {\r\n            Thread t = new Thread (new ParameterizedThreadStart(WriteY)); // Kick off a new thread\r\n            t.Start(\"y\");                               // running WriteY()\r\n        \r\n            // Simultaneously, do something on the main thread.\r\n            for (int i = 0; i < 1000; i++) Console.Write (\"x\");\r\n        }\r\n\r\n        static void WriteY(object y)\r\n        {\r\n            for (int i = 0; i < 1000; i++) Console.Write (y);\r\n        }"},{"label":"Local variables on different Threads","content":"        static void Main()\r\n        {\r\n            new Thread(Go).Start();      // Call Go() on a new thread\r\n            Go();                         // Call Go() on the main thread\r\n        }\r\n\r\n        static void Go()\r\n        {\r\n            // Declare and use a local variable - 'cycles'\r\n            for (int cycles = 0; cycles < 5; cycles++) Console.Write('?');\r\n        }"},{"label":"Object fields on different Threads","content":"\r\n        bool done;\r\n\r\n        static void Main()\r\n        {\r\n            Program tt = new Program();   // Create a common instance\r\n            new Thread(tt.Go).Start();\r\n            tt.Go();\r\n        }\r\n\r\n        // Note that Go is now an instance method\r\n        void Go()\r\n        {\r\n            if (!done) { done = true; Console.WriteLine(\"Done\"); }\r\n        }"},{"label":"Static fields are shared between all threads","content":"\r\n        static bool done;    // Static fields are shared between all threads\r\n\r\n        static void Main()\r\n        {\r\n            new Thread(Go).Start();\r\n            Go();\r\n        }\r\n\r\n        static void Go()\r\n        {\r\n            if (!done) { done = true; Console.WriteLine(\"Done\"); }\r\n        }"},{"label":"Worsen thread safety","content":"        static void Go()\r\n        {\r\n            if (!done) { Console.WriteLine(\"Done\"); done = true; }\r\n        }"},{"label":"Thread Safe access to fields","content":"\r\n        static bool done;\r\n        static readonly object locker = new object();\r\n\r\n        static void Main()\r\n        {\r\n            new Thread(Go).Start();\r\n            Go();\r\n        }\r\n\r\n        static void Go()\r\n        {\r\n            lock (locker)\r\n            {\r\n                if (!done) { Console.WriteLine(\"Done\"); done = true; }\r\n            }\r\n        }"},{"label":"Lock to Monitor","content":"\r\n        static bool done;\r\n        static readonly object locker = new object();\r\n\r\n        static void Main()\r\n        {\r\n            new Thread(Go).Start();\r\n            Go();\r\n        }\r\n\r\n        static void Go()\r\n        {\r\n            bool lockWasTaken = false;\r\n            var temp = locker;\r\n            try\r\n            {\r\n                Monitor.Enter(temp, ref lockWasTaken);\r\n                {\r\n                    if (!done) { Console.WriteLine(\"Done\"); done = true; }\r\n                }\r\n            }\r\n            finally\r\n            {\r\n                if (lockWasTaken) Monitor.Exit(temp);\r\n            }\r\n        }"},{"label":"Deadlocks","content":"\r\n        static bool done;\r\n        static object locker1 = new object();\r\n        static object locker2 = new object();\r\n\r\n        static void Main()\r\n        {\r\n            new Thread(() =>\r\n            {\r\n                lock (locker1)\r\n                {\r\n                    Thread.Sleep(1000);\r\n                    lock (locker2) // Deadlock\r\n                    {\r\n                        if (!done) { Console.WriteLine(\"Done\"); done = true; }\r\n                    }\r\n                }\r\n            }).Start();\r\n\r\n            lock (locker2)\r\n            {\r\n                Thread.Sleep(1000); // Deadlock\r\n                {\r\n                    if (!done) { Console.WriteLine(\"Done\"); done = true; }\r\n                }\r\n            }\r\n        }"},{"label":"Thread Sleep and Join","content":"\r\n        static void Main()\r\n        {\r\n            Thread t = new Thread(Go);\r\n            t.Start();\r\n            t.Join();\r\n            Console.WriteLine(\"Thread t has ended!\");\r\n\r\n            //Thread.Sleep(TimeSpan.FromHours (1));  // sleep for 1 hour\r\n            //Thread.Sleep (500);  // sleep for 500 milliseconds\r\n        }\r\n\r\n        static void Go()\r\n        {\r\n            for (int i = 0; i < 1000; i++) Console.Write(\"y\");\r\n        }"},{"label":"Foreground and Background Threads","content":"        static void Main(string[] args)\r\n        {\r\n            Thread worker = new Thread(() => Console.ReadLine());\r\n            //worker.IsBackground = true;\r\n            worker.Start();\r\n            // how to wait?\r\n        }"},{"label":"Exception Handling","content":"\r\n        public static void Main()\r\n        {\r\n            try\r\n            {\r\n                var thread = new Thread(Go);\r\n                //thread.IsBackground = true; // see what happens\r\n                thread.Start();                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                // We'll never get here!\r\n                Console.WriteLine($\"Exception! {ex.Message}\");\r\n            }\r\n\r\n            // how to handle?\r\n        }\r\n\r\n        static void Go() { throw null; }   // Throws a NullReferenceException"},{"label":"Mutex","content":"\r\n        //A Mutex is like a C# lock, but it can work across multiple processes.\r\n        //In other words, Mutex can be computer-wide as well as application-wide.\r\n        \r\n        static void Main()\r\n        {\r\n            // Naming a Mutex makes it available computer-wide. Use a name that's\r\n            // unique to your company and application (e.g., include your URL).\r\n\r\n            using (var mutex = new Mutex(false, \"TMS.NET06.Lesson11.Multithreading\"))\r\n            {\r\n                // Wait a few seconds if contended, in case another instance\r\n                // of the program is still in the process of shutting down.\r\n\r\n                if (!mutex.WaitOne(TimeSpan.FromSeconds(3), false))\r\n                {\r\n                    Console.WriteLine(\"Another app instance is running. Bye!\");\r\n                    return;\r\n                }\r\n                RunProgram();\r\n            }\r\n        }\r\n\r\n        static void RunProgram()\r\n        {\r\n            Console.WriteLine(\"Running. Press Enter to exit\");\r\n            Console.ReadLine();\r\n        }"},{"label":"Semaphore","content":"\r\n        // A semaphore is like a nightclub: it has a certain capacity, enforced by a bouncer.\r\n        // A semaphore with a capacity of one is similar to a Mutex or lock,\r\n        // except that the semaphore has no “owner” — it’s thread-agnostic.\r\n        // Any thread can call Release on a Semaphore, whereas with Mutex and lock,\r\n        // only the thread that obtained the lock can release it.\r\n\r\n        static SemaphoreSlim _sem = new SemaphoreSlim(3);    // Capacity of 3\r\n\r\n        static void Main()\r\n        {\r\n            for (int i = 1; i <= 5; i++) new Thread(Enter).Start(i);\r\n        }\r\n\r\n        static void Enter(object id)\r\n        {\r\n            Console.WriteLine(id + \" wants to enter\");\r\n            _sem.Wait();\r\n            Console.WriteLine(id + \" is in!\");           // Only three threads\r\n            Thread.Sleep(1000 * (int)id);               // can be here at\r\n            Console.WriteLine(id + \" is leaving\");     // a time.\r\n            _sem.Release();\r\n        }"},{"label":"Immutable objects","content":"\r\n        // An immutable object is one whose state cannot be altered — externally or internally.\r\n        // Immutability is a hallmark of functional programming — where instead of mutating an object,\r\n        // you create a new object with different properties.\r\n        // Immutability is also valuable in multithreading in that it avoids the problem of shared writable state.\r\n\r\n        public static void Main()\r\n        {            \r\n            // how to fix?           \r\n                   \r\n            var hello = new char [] {'H', 'e', 'l', 'l', 'o'};\r\n            new Thread(() => Console.WriteLine((hello.ToUpper()))).Start();\r\n            Console.WriteLine(hello.ToLower());\r\n        }\r\n\r\n        private static char[] ToUpper(this char[] obj)\r\n        {\r\n            for (int i = 0; i < obj.Length; i++)\r\n            {\r\n                obj[i] = char.ToUpper(obj[i]);\r\n            }\r\n\r\n            return obj;\r\n        }\r\n\r\n        private static char[] ToLower(this char[] obj)\r\n        {\r\n            for (int i = 0; i < obj.Length; i++)\r\n            {\r\n                obj[i] = char.ToLower(obj[i]);\r\n            }\r\n\r\n            return obj;\r\n        }"}]}