{"codeFragments":[{"label":"Threads and memory","content":"        static void Main(string[] args)\r\n        {          \r\n            Console.WriteLine(\"Hello world!\");\r\n            int i = 1;\r\n            while(true)\r\n            {\r\n\t            new Thread(obj =>\r\n\t            {\r\n\t\t            while (true) Thread.Sleep(100);\r\n\t            }).Start();\r\n\t            Console.WriteLine($\"{i++}: {Process.GetCurrentProcess().PagedMemorySize64 / 2048}MB\");\r\n            }\r\n        }"},{"label":"Operation throughput example","content":"\t\tprivate static int counter;\r\n\t\tprivate const int OperationDuration = 2000;\r\n\r\n\t\tprivate static int MaxThreads\r\n\t\t{\r\n\t\t\tget\r\n\t\t\t{\r\n\t\t\t\tThreadPool.GetMaxThreads(out var workerThreads, out _);\r\n\t\t\t\treturn workerThreads;\r\n\t\t\t}\r\n\t\t}\r\n\t\tprivate static int AvailableThreads\r\n\t\t{\r\n\t\t\tget\r\n\t\t\t{\r\n\t\t\t\tThreadPool.GetAvailableThreads(out var workerThreads, out _);\r\n\t\t\t\treturn workerThreads;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstatic void Main(string[] args)\r\n        {\r\n\t        ThreadPool.SetMaxThreads(10, 10);\r\n\t\t\tConsole.WriteLine($\"Starting with thread capacity {MaxThreads}\");\r\n\t        var timer = new Timer(TimerTick);\r\n\r\n\t\t\tConsole.WriteLine(\"Performing operation...\");\r\n\t\t\tvar sw = new Stopwatch();\r\n\t\t\tsw.Start();\r\n\t\t\tDoOperationAsync().Wait();\r\n\t\t\tsw.Stop();\r\n\t\t\tConsole.WriteLine($\"Single operation completes in {sw.ElapsedMilliseconds} ms.\");\r\n\r\n\t\t\ttimer.Change(0, 1000);\r\n\t        Thread.Sleep(10000);\r\n\t        Console.WriteLine($\"Operations completed: {counter}\");\r\n        }\r\n\r\n\t\tprivate static void TimerTick(object state)\r\n        {\r\n\t        for (int i = 0; i < 100; i++)\r\n\t        {\r\n\t\t        DoOperationAsync();\r\n\t        }\r\n\t\t\tConsole.WriteLine($\"Added another 100 operations. Threads available {AvailableThreads}\");\r\n        }\r\n\r\n        private static async Task DoOperationAsync()\r\n        {\r\n\t        await Task.Yield();\r\n\t\t\tThread.Sleep(OperationDuration);\r\n\t\t\t//await Task.Delay(OperationDuration);\r\n\t        Interlocked.Increment(ref counter);\r\n        }"},{"label":"SynchronizaitonContext example","content":"          /// <summary>The queue of work items.</summary>\r\n            private readonly BlockingCollection<KeyValuePair<SendOrPostCallback, object>> m_queue;\r\n            /// <summary>The processing thread.</summary>\r\n            private readonly Thread m_thread;\r\n\r\n            public SingleThreadSynchronizationContext()\r\n                : this(new BlockingCollection<KeyValuePair<SendOrPostCallback, object>>(), Thread.CurrentThread)\r\n            {\r\n            }\r\n\r\n            public SingleThreadSynchronizationContext(BlockingCollection<KeyValuePair<SendOrPostCallback, object>> queue, Thread currentThread)\r\n            {\r\n                m_queue = queue;\r\n                m_thread = currentThread;\r\n            }\r\n\r\n            /// <summary>Dispatches an asynchronous message to the synchronization context.</summary>\r\n            /// <param name=\"d\">The System.Threading.SendOrPostCallback delegate to call.</param>\r\n            /// <param name=\"state\">The object passed to the delegate.</param>\r\n            public override void Post(SendOrPostCallback d, object state)\r\n            {\r\n                if (d == null) throw new ArgumentNullException(\"d\");\r\n                this.m_queue.Add(new KeyValuePair<SendOrPostCallback, object>(d, state));\r\n            }\r\n\r\n            /// <summary>Not supported.</summary>\r\n            public override void Send(SendOrPostCallback d, object state)\r\n            {\r\n                throw new NotSupportedException(\"Synchronously sending is not supported.\");\r\n            }\r\n\r\n            public override SynchronizationContext CreateCopy()\r\n            {\r\n                return new SingleThreadSynchronizationContext(this.m_queue, this.m_thread);\r\n            }\r\n\r\n            /// <summary>Runs an loop to process all queued work items.</summary>\r\n            public void RunOnCurrentThread()\r\n            {\r\n                foreach (var workItem in this.m_queue.GetConsumingEnumerable())\r\n                    workItem.Key(workItem.Value);\r\n            }\r\n\r\n            /// <summary>Notifies the context that no more work will arrive.</summary>\r\n            public void Complete() { this.m_queue.CompleteAdding(); }\r\n        }\r\n\r\n        private const int OperationDuration = 1000;\r\n\r\n\t\tstatic async Task<int> Main(string[] args)\r\n\t\t{\r\n            var context = new SingleThreadSynchronizationContext();\r\n            SynchronizationContext.SetSynchronizationContext(context);\r\n\r\n            var runAllTask = RunAllTasks();\r\n            \r\n            #region SECRET\r\n            runAllTask.ContinueWith(t => context.Complete());\r\n            context.RunOnCurrentThread();\r\n\t\t\t#endregion SECRET\r\n\r\n\t\t\tawait runAllTask;\r\n            return 0;\r\n\t\t}\r\n\r\n\t\tprivate static async Task RunAllTasks()\r\n\t\t{\r\n\t\t\tConsole.WriteLine($\"Main 1: {Thread.CurrentThread.ManagedThreadId}\");\r\n\t\t\tawait DoOperationAsync(1);\r\n\r\n\t\t\tConsole.WriteLine($\"Main 2: {Thread.CurrentThread.ManagedThreadId}\");\r\n\t\t\tawait DoOperationAsync(2);\r\n\r\n\t\t\tConsole.WriteLine($\"Main 3: {Thread.CurrentThread.ManagedThreadId}\");\r\n\t\t\tawait DoOperationAsync(3);\r\n\r\n        }\r\n\r\n        private static async Task DoOperationAsync(int num)\r\n        {\r\n\t        await Task.Delay(OperationDuration);\r\n\t        Console.WriteLine($\"DoOperationAsync {num}: {Thread.CurrentThread.ManagedThreadId}\");\r\n\t\t}"},{"label":"TaskAggregateException example","content":"\r\n        public static void Main()\r\n        {\r\n            var task1 = Task.Run( () => { throw new CustomException(\"This exception is expected!\"); } );\r\n\r\n            try\r\n            {\r\n                task1.Wait();\r\n            }\r\n            catch (AggregateException ae)\r\n            {\r\n                foreach (var e in ae.InnerExceptions) {\r\n                    // Handle the custom exception.\r\n                    if (e is CustomException) {\r\n                        Console.WriteLine(e.Message);\r\n                    }\r\n                    // Rethrow any other exception.\r\n                    else {\r\n                        throw e;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        public class CustomException : Exception\r\n        {\r\n            public CustomException(String message) : base(message)\r\n            {}\r\n        }\r\n    }"},{"label":"Async void example with exceptions","content":"      static Task<int> Main(string[] args)\r\n        {            \r\n            try\r\n            {\r\n                DoJob();\r\n                Console.WriteLine(\"Good!\");\r\n                return Task.FromResult(0);\r\n            }\r\n            catch\r\n            {\r\n                Console.WriteLine(\"Error!\");\r\n                return Task.FromResult(1);\r\n            }\r\n        }\r\n\r\n        static async void DoJob()\r\n        {\r\n            throw new InvalidOperationException();\r\n        }"},{"label":"Async IO example","content":"        private const int BUFFER_SIZE = 4096;\r\n\r\n\t\tprivate static void Main(string[] args)\r\n\t\t{\r\n\t\t\tTask t = ProcessAsynchronousIO();\r\n\t\t\tt.GetAwaiter().GetResult();\r\n\t\t}\r\n\r\n\t\tprivate static async Task ProcessAsynchronousIO()\r\n\t\t{\r\n\t\t\tusing (var stream = new FileStream(\"test1.txt\", FileMode.Create,\r\n\t\t\t\tFileAccess.ReadWrite, FileShare.None, BUFFER_SIZE))\r\n\t\t\t{\r\n\t\t\t\tConsole.WriteLine(\"1. Uses I/O Threads: {0}\", stream.IsAsync);\r\n\r\n\t\t\t\tbyte[] buffer = Encoding.UTF8.GetBytes(CreateFileContent());\r\n\t\t\t\tTask t = stream.WriteAsync(buffer, 0, buffer.Length);\r\n\t\t\t\tawait t;\r\n\t\t\t}\r\n\r\n\t\t\tusing (var stream = new FileStream(\"test2.txt\", FileMode.Create, FileAccess.ReadWrite,\r\n\t\t\t\tFileShare.None, BUFFER_SIZE, FileOptions.Asynchronous))\r\n\t\t\t{\r\n\t\t\t\tConsole.WriteLine(\"2. Uses I/O Threads: {0}\", stream.IsAsync);\r\n\r\n\t\t\t\tbyte[] buffer = Encoding.UTF8.GetBytes(CreateFileContent());\r\n\t\t\t\tTask t = stream.WriteAsync(buffer, 0, buffer.Length);\r\n\t\t\t\tawait t;\r\n\t\t\t}\r\n\r\n\t\t\tusing (FileStream stream = File.Create(\"test3.txt\", BUFFER_SIZE, FileOptions.Asynchronous))\r\n\t\t\t{\r\n\t\t\t\tusing (var sw = new StreamWriter(stream))\r\n\t\t\t\t{\r\n\t\t\t\t\tConsole.WriteLine(\"3. Uses I/O Threads: {0}\", stream.IsAsync);\r\n\t\t\t\t\tawait sw.WriteAsync(CreateFileContent());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tusing (var sw = new StreamWriter(\"test4.txt\", true))\r\n\t\t\t{\r\n\t\t\t\tConsole.WriteLine(\"4. Uses I/O Threads: {0}\", ((FileStream)sw.BaseStream).IsAsync);\r\n\t\t\t\tawait sw.WriteAsync(CreateFileContent());\r\n\t\t\t}\r\n\r\n\t\t\tConsole.WriteLine(\"Starting parsing files in parallel\");\r\n\r\n\t\t\tvar readTasks = new Task<long>[4];\r\n\t\t\tfor (int i = 0; i < 4; i++)\r\n\t\t\t{\r\n\t\t\t\treadTasks[i] = SumFileContent(string.Format(\"test{0}.txt\", i + 1));\r\n\t\t\t}\r\n\r\n\t\t\tlong[] sums = await Task.WhenAll(readTasks);\r\n\r\n\t\t\tConsole.WriteLine(\"Sum in all files: {0}\", sums.Sum());\r\n\r\n\t\t\tConsole.WriteLine(\"Deleting files...\");\r\n\r\n\t\t\tvar deleteTasks = new Task[4];\r\n\t\t\tfor (int i = 0; i < 4; i++)\r\n\t\t\t{\r\n\t\t\t\tstring fileName = string.Format(\"test{0}.txt\", i + 1);\r\n\t\t\t\tdeleteTasks[i] = SimulateAsynchronousDelete(fileName);\r\n\t\t\t}\r\n\r\n\t\t\tawait Task.WhenAll(deleteTasks);\r\n\r\n\t\t\tConsole.WriteLine(\"Deleting complete.\");\r\n\t\t}\r\n\r\n\t\tprivate static string CreateFileContent()\r\n\t\t{\r\n\t\t\tvar sb = new StringBuilder();\r\n\t\t\tfor (int i = 0; i < 100000; i++)\r\n\t\t\t{\r\n\t\t\t\tsb.AppendFormat(\"{0}\", new Random(i).Next(0, 99999));\r\n\t\t\t\tsb.AppendLine();\r\n\t\t\t}\r\n\t\t\treturn sb.ToString();\r\n\t\t}\r\n\r\n\t\tprivate static async Task<long> SumFileContent(string fileName)\r\n\t\t{\r\n\t\t\tusing (var stream = new FileStream(fileName, FileMode.Open,\r\n\t\t\t\tFileAccess.Read, FileShare.None, BUFFER_SIZE, FileOptions.Asynchronous))\r\n\t\t\tusing (var sr = new StreamReader(stream))\r\n\t\t\t{\r\n\t\t\t\tlong sum = 0;\r\n\t\t\t\twhile (sr.Peek() > -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring line = await sr.ReadLineAsync();\r\n\t\t\t\t\tsum += long.Parse(line);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn sum;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate static Task SimulateAsynchronousDelete(string fileName)\r\n\t\t{\r\n\t\t\treturn Task.Run(() => File.Delete(fileName));\r\n\t\t}"},{"label":"TaskAggregarte multiple exceptions example","content":"        public static void Main()\r\n        {\r\n            var task1 = Task.Run( () => { throw new CustomException(\"This exception is expected!\"); } );\r\n\r\n            while(! task1.IsCompleted) {}\r\n\r\n            if (task1.Status == TaskStatus.Faulted) {\r\n                foreach (var e in task1.Exception.InnerExceptions) {\r\n                    // Handle the custom exception.\r\n                    if (e is CustomException) {\r\n                        Console.WriteLine(e.Message);\r\n                    }\r\n                    // Rethrow any other exception.\r\n                    else {\r\n                        throw e;\r\n                    }\r\n                }\r\n            }\r\n        }"}]}