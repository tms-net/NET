# JAVASCRIPT

## Получение данных с сервера
Другой очень распространённой задачей в современных веб-сайтах и ​​приложениях является получение отдельных элементов данных с сервера для обновления разделов веб-страницы без необходимости загрузки всей новой страницы. Эта, казалось бы, небольшая деталь оказала огромное влияние на производительность и поведение сайтов, поэтому в этой статье мы объясним концепцию и рассмотрим технологии, которые делают это возможным, например XMLHttpRequest и API Fetch.

### В чем проблема?
Первоначальная загрузка страницы в Интернете была простой - вы отправляли запрос на сервер web-сайта, и если всё работает, как и должно, то вся необходимая информация о странице будет загружена и отображена на вашем компьютере.

![](./materials/traditional-loading.svg)

Проблема с этой моделью заключается в том, что всякий раз, когда вы хотите обновить любую часть страницы, например, чтобы отобразить новый набор продуктов или загрузить новую страницу, вам нужно снова загрузить всю страницу. Это очень расточительно и приводит к плохому пользовательскому опыту, особенно по мере того, как страницы становятся все более сложными.

### Появление Ajax
Это привело к созданию технологий, позволяющих веб-страницам запрашивать небольшие фрагменты данных (например, HTML, XML, JSON или обычный текст) и отображать их только при необходимости, помогая решать проблему, описанную выше.

Это достигается с помощью таких API, как XMLHttpRequest или - более новой - Fetch API. Эти технологии позволяют веб-страницам напрямую обрабатывать запросы HTTP для определённых ресурсов, доступных на сервере, и форматировать результирующие данные по мере необходимости перед их отображением.

> Примечание: Вначале эта общая техника была известна как Асинхронный JavaScript и XML (Ajax), поскольку она, как правило, использовала XMLHttpRequest для запроса данных XML. В наши дни это обычно не так (вы, скорее всего, будете использовать XMLHttpRequest или Fetch для запроса JSON), но результат все тот же, и термин «Ajax» по-прежнему часто используется для описания этой техники.

![](./materials/fetch-update.svg.svg)

Модель Ajax предполагает использование веб-API в качестве прокси для более разумного запроса данных, а не просто для того, чтобы браузер перезагружал всю страницу. Давайте подумаем о значении этого:

  - Перейдите на один из ваших любимых сайтов, богатых информацией, таких как Amazon, YouTube и т.д., и загрузите его.
  - Теперь найдите что-нибудь, например, новый продукт. Основной контент изменится, но большая часть информации, подобной заголовку, нижнему колонтитулу, навигационному меню и т. д., останется неизменной.

Это действительно хорошо, потому что:

  - Обновления страницы намного быстрее, и вам не нужно ждать перезагрузки страницы, а это означает, что сайт работает быстрее и воспринимается более отзывчивым.
  - Меньше данных загружается при каждом обновлении, что означает меньшее потребление пропускной способности. Это не может быть такой большой проблемой на рабочем столе в широкополосном подключении, но это серьёзная проблема на мобильных устройствах и в развивающихся странах, которые не имеют повсеместного быстрого интернет-сервиса.

Чтобы ускорить работу, некоторые сайты также сохраняют необходимые файлы и данные на компьютере пользователя при первом обращении к сайту, а это означает, что при последующих посещениях они используют локальные версии вместо загрузки свежих копий, как при первой загрузке страницы. Содержимое загружается с сервера только при его обновлении.

### Основной запрос Ajax
Давайте посмотрим, как обрабатывается такой запрос, используя как [XMLHttpRequest](https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest), так и [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API). В этих примерах мы будем запрашивать данные из нескольких текстовых файлов и использовать их для заполнения области содержимого.

### Fetch API
Давайте рассмотрим пару примеров Fetch API.

**Получение текстового содержимого**

В этом примере мы будем запрашивать данные из нескольких разных текстовых файлов и использовать их для заполнения области содержимого.

Эта серия файлов будет действовать как наша поддельная база данных; в реальном приложении мы, скорее всего, будем использовать серверный язык, такой как PHP, Python или Node, для запроса наших данных из базы данных. Здесь, однако, мы хотим сохранить простоту и сосредоточиться на клиентской части.

Чтобы начать этот пример, сделайте локальную копию файла `ajax.html` и четырех текстовых файлов — `verse1.txt` , `verse2.txt` , `verse3.txt` и `verse4.txt` — в новом каталоге на вашем компьютере. В этом примере мы получим другой стих стихотворения (который вы, возможно, узнаете), когда он будет выбран в раскрывающемся меню.

Внутри `<script>` элемента добавьте следующий код. Он сохраняет ссылки на элементы `<select>` и `<pre>` и добавляет прослушиватель к `<select>` элементу, поэтому, когда пользователь выбирает новое значение, новое значение передается функции, названной `updateDisplay()` в качестве параметра.

```
const verseChoose = document.querySelector('select');
const poemDisplay = document.querySelector('pre');

verseChoose.addEventListener('change', () => {
  const verse = verseChoose.value;
  updateDisplay(verse);
});
```

Определим нашу `updateDisplay()` функцию. Прежде всего, поместите следующее под предыдущим блоком кода — это пустая оболочка функции.

```
function updateDisplay(verse) {

}
```

Мы начнем нашу функцию с создания относительного URL-адреса, указывающего на текстовый файл, который мы хотим загрузить, так как он понадобится нам позже. Значение `<select>` элемента в любое время совпадает с текстом внутри выбранного `<option>` (если вы не укажете другое значение в атрибуте значения) — например, «Стих 1». Соответствующий текстовый файл стиха называется `"verse1.txt"` и находится в том же каталоге, что и файл HTML, поэтому достаточно будет указать только имя файла.

Однако веб-серверы, как правило, чувствительны к регистру, и в имени файла нет пробела. Чтобы преобразовать «Verse 1» в «verse1.txt», нам нужно преобразовать букву V в нижний регистр, удалить пробел и добавить .txt в конце. Это можно сделать с помощью replace(), toLowerCase()и конкатенации строк . Добавьте следующие строки внутри вашей updateDisplay()функции:

```
verse = verse.replace(' ', '').toLowerCase();
const url = `${verse}.txt`;
```

Наконец мы готовы использовать Fetch API:

```
// Call `fetch()`, passing in the URL.
fetch(url)
  // fetch() returns a promise. When we have received a response from the server,
  // the promise's `then()` handler is called with the response.
  .then((response) => {
    // Our handler throws an error if the request did not succeed.
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    // Otherwise (if the response succeeded), our handler fetches the response
    // as text by calling response.text(), and immediately returns the promise
    // returned by `response.text()`.
    return response.text();
  })
  // When response.text() has succeeded, the `then()` handler is called with
  // the text, and we copy it into the `poemDisplay` box.
  .then((text) => poemDisplay.textContent = text)
  // Catch any errors that might happen, and display a message
  // in the `poemDisplay` box.
  .catch((error) => poemDisplay.textContent = `Could not fetch verse: ${error}`);
```

Здесь есть что объяснить.

Во-первых, точка входа в Fetch API — это глобальная функция с именем `fetch()`, которая принимает URL-адрес в качестве параметра (она принимает еще один необязательный параметр для пользовательских настроек, но мы его здесь не используем).

Далее `fetch()` идет асинхронный API, который возвращает файл `Promise`. 

Так как `fetch()` возвращает Promise, мы передаем функцию в `then()` метод возвращенного Promise. Этот метод будет вызываться, когда HTTP-запрос получит ответ от сервера. В обработчике мы проверяем успешность запроса и выдаем ошибку, если нет. В противном случае мы вызываем `response.text()`, чтобы получить тело ответа в виде текста.

Оказывается, `response.text()` это тоже асинхронно, поэтому мы возвращаем Promise, который он возвращает, и передаем функцию в метод `then()` этого нового промиса. Эта функция будет вызываться, когда текст ответа будет готов, и внутри нее мы будем обновлять наш `<pre>` блок с текстом.

Наконец, мы добавляем обработчик `catch()` в конце, чтобы перехватывать любые ошибки, возникающие в любой из вызванных нами асинхронных функций или в их обработчиках.

Одна проблема с примером в его нынешнем виде заключается в том, что он не показывает стихотворение при первой загрузке. Чтобы исправить это, добавьте следующие две строки внизу кода (чуть выше закрывающего тега `</script>`), чтобы по умолчанию загружать стих 1, и убедитесь, что элемент `<select>` всегда показывает правильное значение:

```
updateDisplay('Verse 1');
verseChoose.value = 'Verse 1';
```

**Обработка примера с сервера**

Современные браузеры не будут выполнять HTTP-запросы, если вы просто запустите пример из локального файла. Это связано с ограничениями безопасности. Чтобы обойти это, нам нужно протестировать пример, запустив его через локальный веб-сервер.

### API XMLHttpRequest
Иногда, особенно в старом коде, вы увидите другой API, называемый `XMLHttpRequest` (часто сокращенно «XHR»), используемый для выполнения HTTP-запросов. Это предшествовало Fetch и было действительно первым API, широко используемым для реализации AJAX. Мы рекомендуем вам использовать Fetch: это более простой API и имеет больше возможностей, чем `XMLHttpRequest`. Мы не будем рассматривать пример, в котором используется XMLHttpRequest, но покажем вам, как XMLHttpRequestбудет выглядеть версия нашего первого запроса на хранение:

```
const request = new XMLHttpRequest();

try {
  request.open('GET', 'products.json');

  request.responseType = 'json';

  request.addEventListener('load', () => initialize(request.response));
  request.addEventListener('error', () => console.error('XHR error'));

  request.send();

} catch (error) {
  console.error(`XHR error ${request.status}`);
}
```

Для этого есть пять этапов:

  - Создайте новый объект `XMLHttpRequest`.
  - Вызовите его метод `open()`, чтобы инициализировать его.
  - Добавьте к его событию прослушиватель событий `load`, который срабатывает после успешного завершения ответа. В слушателе мы вызываем `initialize()` с данными.
  - Добавьте к его событию прослушиватель событий `error`, который срабатывает, когда запрос обнаруживает ошибку.
  - Отправьте запрос.

Мы также должны обернуть все это в блок try...catch , чтобы обрабатывать любые ошибки, выдаваемые `open()` или `send()`.

## Веб хранилище (API)
Web Storage API предоставляет механизмы, при помощи которых браузеры могут безопасно хранить пары ключ/значение в более интуитивно понятной манере, чем куки (cookies).
### Основы Веб хранилища и его использование
В основе Веб хранилища лежат два механизма:

  - хранилище сессии (`sessionStorage`) обслуживает область хранения данных для каждого домена, доступное на протяжении сессии. (пока браузер открыт, даже в случае перезагрузки страницы)
  - локальное хранилище (`localStorage`) делает то же самое, но сохраняет данные даже в случае, если переоткрыть браузер.

Обе функции доступны через `Window.sessionStorage` и `Window.localStorage` свойства (если быть более точным, в браузерах, поддерживающих хранилища объект Window выполняет объекты `WindowLocalStorage` и `WindowSessionStorage`, которые содержат свойства `localStorage` и `sessionStorage`) — вызов одного из них создаёт представление объекта `Storage`, через который можно устанавливать, редактировать и удалять данные. Для каждого из типа хранилищ и по каждому домену используется отдельное представление `Storage` объекта - они функционируют и управляются отдельно друг от друга.

> Замечание: Начиная с версии 45 Firefox, когда браузер прекращает работу/перезагружается, объем данных, сохранённых для каждого источника, ограничивается 10 МБ. Это было сделано, чтобы избежать проблем с памятью, вызванных чрезмерным использованием веб-хранилища.

> Замечание: Доступ к веб хранилищу из iFrame третьей стороны запрещён, если пользователь отключил cookies третьих сторон (Firefox ведёт себя так с версии 43).

> Замечание: Web Storage это не тоже самое, что mozStorage (Mozilla's XPCOM интерфейсы для SQLite) или Session store API (XPCOM утилита хранения для расширений).

### Интерфейсы Веб хранилища
**Storage**

Позволяет присваивать, извлекать (читать) и удалять данные для специфического домена и типа хранилища (сессии или локального).

**Window**

Web Storage API расширяет `Window` объект, добавляя к нему два новых свойства — `Window.sessionStorage` и `Window.localStorage` — которые предоставляют доступ к сессии текущего домена и к соответствующим локальным Storage объектам, и обработчик событий `Window.onstorage` (en-US) , который срабатывает при изменении объекта хранилища (например, при сохранении нового элемента)

`StorageEvent` (en-US)
Событие storage срабатывает на объекте документа Window при изменении объекта хранилища.